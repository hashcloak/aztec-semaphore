{"noir_version":"1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec","name":"Semaphore","functions":[{"name":"add_member","hash":"8791503969641334451","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"group_id","type":{"kind":"field"},"visibility":"private"},{"name":"member","type":{"kind":"field"},"visibility":"private"},{"name":"tree_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"create_group","hash":"1869353842819809679","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"tree_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"admin_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"initialize","hash":"17817513059392513693","is_unconstrained":true,"custom_attributes":["initializer","external","public"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"group_id","type":{"kind":"field"},"visibility":"private"},{"name":"tree_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"13195480741466493107","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"TL3LsjS7jpz5LnvcgyRIAmC9Sg9krdbFyqxMZabLqF5eK+AE3Sfan6vOT0cwAp6Rkchc//HPf/mv//n//Pf/9K//47/9+//651/+3//45z//z3/9t3/71//+n/7t3////+9//+u//4+//9//+Of3/T/59//O/+efHP/8i//9x/75l/X3n4n/LPxn//Mv+fcfx38C/0n859R/zg//GfiP4T8T/1n4D1Y5WOVglYNVDlYZv9/977j/tfvfef+77n/3/a/f/8b9b97/3vXGXW/c9cZdb9z1xl1v3PXGXW/c9cZdb9z17K5ndz2769ldz+56dtezu57d9eyuZ3e9edebd71515t3vXnXm3e9edebd71515t3vXXXW3e9dddbd71111t3vXXXW3e9dddbd71919t3vX3X23e9fdfbd71919t3vX3X23c9v+v5Xc//1hu/D2bDatgNf2uO+UE0ZMO5EH/rDv/gb2H7/lVYw2xYDbvBG/5WtvVBNpwLX3sAvpX3B9YwG76av8P5GgXgDX8rz/FBNpwLX8sARoM1zIbVsBu8oVc+vfK5K9vXRXN+MBqsYTasht3gDdGQDefC6JVHrzx65dErj1559MqjVx698uiVR69svbL1ytYrW69svbL1yl9/zf1BNGTDufD1GGA0WMNsWA27oVeevfLslWevvHrl1SuvXnn1yqtXXr3y6pVXr7x65dUr715598q7V9698u6Vd6+8e+XdK+9eeffK3it7r+y9svfK3it7r+y9svfK3it7rxy9cvTK0StHrxy9cvTK0StHrxy9cvTK2Stnr5y9cvbK2Stnr5y9cvbK2Stnr3x65dMrVw/mB7NhNewGb4iGbDiAWT1YMBqsYTashr+V1/jAG6Lhb+XlH5wLXw8CRoM1zIbVsBu8IRp65dErW69sN5GmWcNsWA27wRuiIRtuIs35a+iVZ688e+WvB9f5YDd4QzRkw7nw9SBgNFjDbOiVV6+8euXVK389uH8fnAtfDwJGgzXMhtWwG7whGnrl3St7r/z14I4PrGE2rIbd4A3RkA3nwteDgF45euXolaNXjl45euXolaNXjl45e+XslbNXzl45e+XslbNXzl45e+XslU+vfHrl0yufXvn0yqdXPr3y6ZVPr3zuyuv3axgN1jAbVsNu8IZoyIZeefTKo1cevfLolUevPHrl0SuPXnn0yqNXtl7ZemXrla1Xtl7ZemXrla1Xtl7ZeuXZK89eefbKs1eevfLslWevPHvl2SvPXnn1yqtXXr3y6pVXr7x65dUrr1559cqrV9698u6Vd6+8e+XdK+9eeffKu1fevfLulb1X7h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXswugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7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26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26Ybs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkvCyx38sS+70ssd/LEvu9LLHfyxL7vSyx38sS+70ssd/LEvv96DboNug26DboNug26DboNug26DboZnQzuhndjG5Gt8qSUT+tUllyMYhJPA8rSy4OohEncRHpNuk26VZZMqzwPKwsuTiIRpzERdxEJwaRbotum26bbptum26bbptum26bbptum25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26VZaMVZjE01gDiGNE4SAacRIXcROdGMQknoeDboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o9uk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLemWdEu6Jd2Sboduh26Hboduh26Hboduh26Hbue5GbPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSW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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"17038024601172764994","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"tZ3djt02soXfpa99QbKq+JNXCYLASZyBAcMJPMkBDgK/+7CKrEW1B+LIe6tvwi+JexVFcZElltT+5+W3D7/8/a+fP37+/Y9/v/zw4z8vv3z5+OnTx3/9/OmPX9//9fGPz/2//vMS9B+JX36I716SjCa//JB6U0ZTR9OsoTCaOJo0GhoNj0ZGM1RoqHD/Ae5NGg2Nhkcjo8mj6T8gvamjadZIGE0cTRpNVym94dHIaPJoymjqaJo1OYymq8TQ2zTboZOHTh46eejkoZOHTh46ZegU1enjVdJsh04ZOmXolKFThk4ZOmXo1KFTZ3/q7E/tOjH3Vu9K663MNs+2zLbOto226b3pP9/ibNNsabY8W5mt3qF+b1qZbZ2t3uo+vjEEh+iQHMiBHVQ1K2SH4lAd2oQYHFS5KiQHcujKFBXEITsUh+rQJqSuTEkhOnRlYgVyUGUNoRN+QHYoDtWhTdCpzyqok3+AzmZSIAd2EIfsUByqQ5vAwSE6uDK7MrsyuzK7spqD9brUEKz3Qi0hQUEcskNxqA5tgtpjQHRIDuTgymoT0QFXowwoDtWhTVDDDIgOyYEc2MGViysXVy6urAbiPuWjWmhAdEgO5MAO4pAdikN1cOXmymof0dutfhEdcDXMgOrQBiS1zIDokBzIgR3EQZWLQnGoDm2CWmZAdEgO5MAO4uDKahmpCtWhTVDLDIgOyYEc2EEcsoMrJ1dWy2S9LrXMgOjQlTMrkAM7iEN2KA7VoU1QywyIDq7MrsyuzK6slsm6mekmM6A6tAnqpgHRITmQAzuIgyuLK6ubsijoT2UFdhCH7FAcqkOboN4ZEB2SgyrrzVXvDBAHVW4KuvEEherQJtj2YxAdkgM56GZmWYA4ZAdV1lFV7xS9UvWOgXpngCrrlNC9aAA5sIM4ZIfiUB3aAFJ/1agQHZIDObCDOGSH4lAdunJlzWiCQ3RIDqrcFLpys/RHHLJDcagObYL6a0B0SA5duYkCO4hDdigO1aFNUH8NiA6qrAOl/hrADuKgeUQgJc0kQlHSXEKTD6KZ6PHM9HimemxZjhGBGCSgDKqWTpJaS1sZyR8JzZZnK7PNsy2zHSkgycgBKYfZxtmm2dJsR+JFM4OjmcLRzOFoJnE0sziaaRypsayd+ReprwZMxZnL0UzmaGZzNNM5mvkczYSO6lSsMzMkS+kMbMSyko2YzirL6zTxIsvskt4Zy+0G6ehprkTqqkkRlEAEYpCAMqiALIb2oLVJHAIoghKIQAwSUAZpDE2+WH02qTmp0yZpDCpKGkPTLFazTWKQgDKogCpIY3DQ54wAiiCNwVGJQAwSkMZge1opoApqThRAEZRABGKQxdDrNQ8OKqAKak4cQBGUQATSGJqYsTlxUAYVkMYQfbDi4XOWMNs4W/c5C4EYJKAMGj5nGT7nPB/y8nzKy/MxL/tz3nzQy2W281EvD59zCbONs02zpdkOV/J0JU9X8nQlT1fydCVPV/J0JftzFldymIp1KtapWKdinYp1Krap2KZic8Xmis19zs19zs19zs19zq2CdPRy0GfdANJ7nqOSRtBNX8yDurWLeXCQgDKogCqoOZkHB0WQxtCtXcyDgxgkoAwqoApqTubBQRqj2JN7AhGIQRqj6pWbByspFVAFNSfz4KAISiACMchi6EiaBwcVUAU1J/PgoAhKIAJZDB1J8+CgDCoge25nJXtyt8OLAIqgBCIQgwSUQQVUQerzoGOaAyiCEohADBJQBhWQPtZrHiG5OZUAiiCLUZUINM6KpMhs82zLXFWkVFBzUidPiiCyVUcqz3asKmJPdNq20drznLZxtmm2Y1URday1Mts82zLbOls/S5qHSSHONs12niaFeZwU5nlSmAdK5suoUB2mYvTjqakYp2KcinEqxqkYp2J0xeiKcSqmqZimYpqKaSqmqZimYpqK5jk7IasOba5n2Ryn61k2x+l6ls1xuoplc9wgvcPWGzsQHJRBBVRBzclyz0ERlEA6iyIrMUhAGVRAFdScbN8bFEEWww4BCcQgAdnJmV652NmZXq9UUHMyxw2KoAQikMbQU7RsjhuUQRZDx94cN6g5meMGWQy9M+a4QQRikIAyqIAqqDnVAEKMihgVMSpiVMSoiFERQ72Z9LguqzsH2enloAhKII1BOlZ2ikk6LnaOSXYsm0EFVEFtUrEDzUERlEAEYpCAMqiAKggxImLYSSZlJQYJyPSaUgFVUHNKAaQ9ZTtwJhCDBDTW0jIP8Ms8wS/J19FCARRBCUQgy13saDuDCqiCmpPtlYMiKIEIxCDEYMRgxGDEYMQQxBDEEMQQxBDEEMQQxBDEEMQQxMiIkREjI0ZGjIwYGTEyYmTEyIiREaMgRkGMghgFMQpiFMQoiFEQoyBGQYyKGBUxKmJUxKiIURGjIkZFjIoYFTEaYjTEaIjREKMhRkOMhhgNMRpiNI9RQwBFUAIRiEECyqACUk/o6Xk15xqZcwdFUAIRiEECyqACQoyIGAkxEmIkxEiIkRAjIUZCjIQYCTESYlhVTp83qxXmBjHI9EQpgwqogpqT7caDIiiBCMQgKNveylrMsr11EIHsJ7QEZnvroAwqoApqTra3DoqgBCIQlG335KpkKlZKC6AISiACMUhAeZRbqlpwQHVoE6w+YRAdksOs1lTb2/TZpNrepkeO1fa2QRlUQHol1X62TWq2tw2ymlpWSiACMUhAGVRAFqMoNSdzyKAISiACWeUvKqlKIaXmZB4YFEGqoqfJzTwwiEECyqACqqDmZHXqQRGEGIQYhBiEGIQYhBjmC31GbeYLI8s5tRzVbL5rJadZzjmo4v82J5vRono2o/UcptmMNrIZrcWaZjN6UAIRiEECyqACqqDmVBDD5ruWa5rN90EEYpCAMqiAKqg5WbY4CDEqYlTEsGxRdK5ZtjgogwqogpqTZYuDIiiBCIQYDTHMPdKswK1/UI9aOvJCWZgXloV1YQOOovbAuDAt5GmLjrIwLywL68IGNOtMjAvTQlpoIZKhiZFhA5pHJpoYG6aFtJAXysK8sCysCxvQdpGJK4R5o1of7IGs2n+1XWNiWkgLeS52HWVhXujrWMe6sAHNbBPjwrSQFlq0YigL88KysC5sQJvM2XpmszmP1yIa0ObzxLgwLbR7YWK2I+RqWBbWhc1xvMIx0XSbYVpIC3mhLMwLy0JbD4NhA5oDJsaFaSEt5IWy0FbcaFgXNuDYPAbGhWkhLeSFsjAvXNHSijZ2ETVOHNvIwLgwLaSFvFAw6pQXloW4WfZKRC/XGppCMZSFeWFZaP21e2Er70BbeifGhWkhLeSFstCiWc9s0k6sCxvQJu3EuDAtZFzbSGjsHo/sZWDzC7I3JxzjwrTQDBkNeaEsNEPaKz8jjRlYl8KKFle0uKLFFW3M1IG8UBbmhWXhijZmavn69d2Lv3H3819fPnzQF+4Or+D9+M/Ln++/fPj818sPn//+9Ondy/+9//S3/aF///n+s7V/vf/S/28fsA+ff+ttF/z946cPSl/frZ8O5z/ai3n+072GFyHQylWFXjQtU6Fje0Ah2RGbKaS+rp4p0KYPvXLkEtSrRAKNXC/3ohfhvRe9jPrIdZTqY9ktU88U8rlCbS7QDtfQC8KXBdRdU6CeCtRzAU1bZEpoWrLuBqX2SqRtbkfUZ7hxN3pJcUlkutqPqxK7icl6NjbnRJOz26HHWWcS/cEg+Xj2Ai4k+i74WmMzN/uihlkRQjhopNcavNHo5xM+OTvXcDa/o2zGoz9LYEB6pn9qkt3V9GWXcDU5n19N2WgwZml/IDqMiHzTj908rVi3+sa00bjcDzrXuDoehU7HQ9eWM42SXaIf3kGB0/VO2Js6oxO9KHzeid0SavnzmBx9CT0djMS7ftSGhVzOb8rlfmw0ro9HPR+P8pY3JaW1q/G571PbzS4JmKL9gaecWZbCDZvj/+hJPvSk0oMiWJJVhE8vZzdB1iJW1lTX6Xb9zvC6M1lO7wzJbood51ik0/Gg3W5NzTe5fjCaT7cXKjfc3W1HuKAjkjYdadvVFKMqvO5MeS3BYec5pJK93HFIPWJ+rbFZTEWCX4ocL4W+Q6EkKNT4iELGptCRH1KAUaTXns8UdmNZOGAsSzkfy820KGuD7GU0OdfYzU/xweS47kbP818r1J3VGhLz/qB2rrGZnJIwnIeE47sUMDVzlMeuw+rVviGkxzRKzHjE2FzJfnfEqtOXv/PdUXh3V5F+9Yz8PA0Ued7tkp91+1bhktO213HRadKed1oOzzotx+edltOzTtsqXHLa9jouOm2rcYfT7PhpHinEcv6wtNOg0taxxHmykjerhsSMHS0eZmjqxxyX+8HrkOb1o3B6TIPPn1PKmz4scUirE+dPbGV73iSw2mHVke+5q3V1gs9Hc+OTnnTipKavx6sXrzPhsln8MhV4jQ9PF7G8PiMpZfck7j6JhzMv6hd1WUHgtJDOFW5YPuvTy+d2NAUzK/ejltPRrJubmgu2o77qHC3yuh91N7lqxJJRj5tzLY9NrlzOJlfdnTdVHHxRC+fdqHl3GkBEOLMiOX26qbsUtFdS0JNeNImnIrsDSSnRF/POh0zh29Oz3agy+QIYmdvZqLbwvGVbfNayW4VLlm30vGUbP2vZ7WhetGzLz1u2lTe27HFyHY41vp1c7XnLxhBu8GyvL9xg2hjSG7u2sbjlmrCcVwEC72aaOyaXdr7fB7mjChDyHWWA7eVUuDduahphd4RfVoGmc+bzjuymLBVZB8blUD68XvqjzOtM8VCi+bZSFOP2iZgwXyVuZv3OwiHhvFdfyKnnc21bcrK3GodKypvnjntqTvcUnbYXRDhLj7RLl2O55YLqm1+Qvdk0Lyhs7lDaHfHVgmehltr5hNtNW8rYRDu3Gy6Hy2OPM5kwabPw2fYVdwWoq8lRTPJsdrSXuJQexW396WJ+FFN9NkHaD+nFDCnuSlBXU6RI8Y1zpOMky6cJeNwWoAhrdE906LwftEtdQyOohCbn7t1VoSik5d6Q2nmStKv+kGTc48702NaVsRjF3OK5fa9JHLfh/7o57dnjoYszpBzM+z3XUQSbeD8cPpXgdMNKxvT0SraVuLaSsdywknF+eiXbDunVlWxXgLm8ku1qSbesZMdJ1s7NIvGGxz1JdzzuCd3xuLcvS93wuJfCOiAOic5HNt+wR0i5Y4+QescesStQ3bJHvBpZfmht1bdgILFZW3cFpsvTPtMd0z7zHdM+y1tP+4jJluIm/87lhl0r16d3ra3EtV2rhBt2rRKf3rW2Q3p119rVqy7vWoXfdtd6NcnK+a61K7Nctu+u5nTdvqXeYd/S3tq+CTXJlPL5yNZ4g313FayL9t1KXLNv5Rvsu61gXbPvdkiv2ndXwLps310B6xb7HifZ4fnq20m2K7lctu+u/nTdvi3dYd9Gb21fgm0Sb5LOJjfYd1fNumjfrcQ1+7Z6g3231axr9t0O6UX7pl0p66p9066SdYt9j5OMTk+/0q7wc9W+KcgN9k3bStZV+6ZQ3tq+eb0dn6ucj2x73r4phmftu5e4ZN+0G46r9k2RnrXvfkiv2ndXwrps35jf2L6HSbY5H03b8tXFg4kU2w0HE2lXvrp8MJG2BaxbDiZKwIuJJT12MHGUoNPz77SrtTx9eP1qhhA9dh1tTVQp59exq7QGOnxEekxn8rcqu4f4VPCSQa9yhfNPjvYqlVftOMTzubr/hmpVOImPJc7v6gtFbDWd0/m2R7uslStjxnPN9GhfVrWFYgvnfdllA9yioC+N2qN9ET705Xwl2JexAt4S6JwfvUf2uzRmX9JuXLaFV8HnYZ0pnfdl66NS8JVrePVuyzc+2n0JFNey0ve9lRTw671490sCKOGXBNBhTfjm/Zi0q77gm6rD++f8+iOL7ev4FPCdbXfRaTqw/yxgfZ5K4cEPcC72Y/8h0MV+bD8Qw/fxkuWxj9REoJDPPlLbzatmv/J0Jptps5rJ9m3BnPClf8p86v19T/AJTud27rZtIevKS/1he7Yp6wD9/IuRvQSSiHi4J98lce0bnrT9KOrSRzx7iUtf8Wx/K8i1j3h2Enn96oXc6CGJi58BbS8kh3Vo9pjExVUnPL/o7LYBzn5HmI/vJrbLRl3vSMZeZn+kE3F9y6S/neghCWprh2+P9UKwI/bUpTwmkfH2q9T22IWEtlKVxy6EDtmxPHYhGfO7V7Ie60U5vPnTHpqcPYNth83oEYmCtLpwfkSgYQdp8tg4BPy+Gf2Fcucr764o9bxNG3LXlh4bCHi0FXlyJB8TyEI4+DnkNvXybp6xjZbDKef3CNQlUB4SwPpwdNV3CJSE76sP3zmawE/9X9//+vHLq7/x86tKffn4/pdPH+a//v73518P//ev///T/4//jaF/fvnj1w+//f3lgyqtvza0/+PHqH+zTV+u+ad3L6T/Hoq864dm8pP+JsL+H2o/q6wt6r9G+/NZ9M+Xn75qB/8D","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"4225137429508780962","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"update_admin","hash":"16642778443637885832","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"group_id","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZrdbhs5DIXfxde5kMQfSXmVRVGkrbsIEKRFmiywKPLuS454xnaBEWbt9qb8svEcixxydDSbn4cvx09vf398fP767cfh/q+fh08vj09Pj39/fPr2+eH18duz/defh+T/5Hq457tDbof7aqEf7nO6OxT7Xc4Wc8QSkSw2ixxRImrEGrFF7CNSipgjloihR6FHrtctasQasUXsI3KKmCOWiBSRI4Yehx6HHoceu57lLSlijlgiUkSOKBE1Yo3YIoaehp6Gnoae2ueL1VFbxD5iTRFzxBKRInJEiagRQ6+6XrHYR2wpYo7o19ltbv45sdhH7ClijlgiUkT/Xlt3l4gasUZsEfuIOSVABrhkcyAAAwSggApw4e7QA3ICZIAJUnJggABMkLJDBTRADyhR21wYIAAFVEADRIUzJUAGFICOameKMmdOgAwoAAIwIIqdWQEV0AAouKDggoJ77w5AwQUFFxRcUHBBwb2DB6DgioIrCu5dPMALTg5ecM9UFVABLcB7mtTBr/KFeRcPUEAFNEAP8FYm/1Lv5QEFQAAGCEABFeDKXl7v/QW8+QdkgCmz94/3/wBTZs/UJ2CAAirAlNlL51Mg/pT0KRByyICCXxHAlEUcBKCACjBlUYce4FMwIANMWf0rfBwGMEAACqiABugB/sgfkAFQ9klRdmCAABRQAQ3QA3xSBmRAAUCZoExQ9iHS4lABDdADfKwGZEABEIABAoAyQ9mHSL2YPkQDCoAADBCAAiqgAXqAQtmHSKtDARCAAX55913UPlx9G/Z9YAABGCAABdgyqqfjQzSgB/gQDciAAiAAA1zZ77sP0YAKaIAe4EM0wJX9xvkQDSAAA1zQG9tnZ0ADuKC6U0iADCiAqDwlBVRAA0TlKSdAVJ5yARCAAVF5KlF5KgVAAAYIQAFReSoNEJUnSoAMKAACMCAqT6SACmiAqDxxAkTliQuAAAxwwcVouaBn6lvJgB7gUzDALm/Zwa5qvjDv8AEN0AO8wwdkgC2j+Zd6hw9ggAAUUAEN0APcFDUvr4/DgAIggCuLgwBc2TP1cRjQAD3Ax6F76XwKlkwbUvYpGCAAE+y+noaUO1LuSNl7vvu3e88PYIDpdO/DjmJ2FLOjmD2UOSVABhQAARggAAWEIC89v/jjAiAAA3xh1aGNNmbfCxbwvWCA6fTmUAAE8AQX6y34sAIqAMoFygRlyoACIAADoEwQXB74i79HgowEGQl6zy958XoVlsFYhrf6koUgQUGC3vxLXoJlCJYhSFCgLFAWKCsSVCSoSFCRoEJZIeg97x6JvecHZEAB+Fkk+adhmxi2iWGbuC4HuOwnnLRSXsmPIckbZLFOfkFjgACg3qDeoN7ClPFinRbIgAKAcofgckhghz5AllPCAhmwrIycZNhgWQ4FC1SAn7LS8vEOymmlJU3/XA5vLZkADIB6hnqGem6AcO1SEiADoFwguJwQ/OtLAyBLQpbLqXdJjnAZYR2EdSxH3SURWtOkNc3lwLskhxOE4AQhOEEIThDCUGeoM7JkZMnIUpClQHk5OMj7+90B7ws+vr4cj/664OwFgr1W+P7wcnx+Pdw/vz093R3+eXh6Wz704/vD8xJfH17st9ayx+cvFk3w6+PT0en97nR12r7UmjW1uNy4t1XCinEhkiciZvSgUbSeSZQLiTKRaKlmaLTUTqlou9CgbQ3zDdJDw7jKlsYsFfKGGsuwzX0zFfkNqegfTsWc55pK2r4rbVuitgqJ2kvfWkSfJGKOpCARcx43J8LbiczaXGntUJXTbZXLQcmTDjUFSKhtwKdV1HqpMenQ7AfKRcLOq6uC99mFAk/uCFeMa5VyqiZlvdSYNCitd4TtKijYufJSYdKedqhFh9uxtm9r1G0NKWhwe45fp9DXG5LlujzsmIU86OyO/KpRZq0lBc9few9Ur9TQvmq0fp2GnczWKSltW4Nm3YXOqKxXKXSWUOhy3Rpsqsu6Ien2fS2T+8pmDtHifL6n9f9RTj5tBHLlbaW1Qw3bVRq/I5VMa4faC87rJqXm9dFVJ/NK5c9q2HvQNRet7TqNuu5q9hZ0e+pJbp2UmcK+SZkp7J0Uaje317Sc/fTg6WW7nNPNVRJSUXM+m5srT2yCVsI6rLvymU24XAfPWrTldUNodLqx9pb7KquhfctqMM9M0+rJ7R0Wba6CZ5t86rSKpC6b5o1nNjSVk3uz00HeFKkzu6HrzTWmTQs4LeppZPVsGb8Wtc/atOR61qeby5A08+VadPXlytsFma+E02klZ0+gX1cy6VRaHx/2CurUqHJNRWtKWxWVmRfV9XBQTyvgq0x5PXNfsv/0WmU9vNa6aeul3m7rpd1q66Xfbus13WrrNd9u67XcauunCrts/TSPnbZe5XZbP9fYZ+unGjttvbZbzcpMYZ9ZmSnsNSs132xW5uXcZ+vnGvts/Uzjd6Sy09ZPJ2WnJa/1z2rstfVTjZ22vqVbJ2WmsG9SWrp9Uhrd3F7Tcu609dPNdaetb3q7rW/1z9r6c6vRN/1Sm70LbQ1Nbv+Hc3sVfWpAiWg1oCSbLrZPpp5yzetKctVNF9tnBlRqzqutN9eyJTKdloQnaS9Xzpuiw3qVWyd2ojDdHXdlMVXYlcXOHXqiMH0hsSuLqcKuLHa+FJkoTF9A7spiqrAri50vQX9V+GA/Pnx+fLn4Q+F3l3p5fPj0dIwfv749fz777eu/3/Eb/KHx95dvn49f3l6OrnT6a2P75y8x1yBNPvgfd/qPdjoRzf5j9h/tYSutfXj3xfwH","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Semaphore::add_member_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::add_member_parameters","fields":[{"name":"group_id","type":{"kind":"field"}},{"name":"member","type":{"kind":"field"}},{"name":"tree_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Semaphore::create_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::create_group_parameters","fields":[{"name":"tree_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"admin_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Semaphore::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::initialize_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"group_id","type":{"kind":"field"}},{"name":"tree_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Semaphore::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"Semaphore::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::sync_private_state_parameters","fields":[]}}]},{"kind":"struct","path":"Semaphore::update_admin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::update_admin_parameters","fields":[{"name":"new_admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"group_id","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"LeanIMT"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"size","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"depth","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"sideNodes","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"leaves","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Semaphore"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"merkle_trees","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"admins","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"group_merkle_tree_duration","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"group_merkle_tree_creation_date","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"group_nullifiers","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"group_counter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"46":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n","path":"std/slice.nr"},"50":{"source":"use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Semaphore {\n    use aztec::macros::functions::{external, initializer};\n    use aztec::{macros::storage::{self, storage}, state_vars::{Map, PublicMutable}};\n    use aztec::protocol_types::address::AztecAddress;\n    use lean_imt::LeanIMT;\n\n    #[storage]\n    struct Storage<Context> {\n        // groupID -> MerkleTree contract address\n        merkle_trees: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        // groupID -> admin address\n        admins: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n\n        // Groups mapping\n        // in semaphore we have mapping(uint256 => Group) public groups where Group has the below components\n        group_merkle_tree_duration: Map<Field, PublicMutable<Field, Context>, Context>,\n        group_merkle_tree_creation_date: Map<Field, Map<Field, PublicMutable<Field, Context>, Context>, Context>,\n        group_nullifiers: Map<Field, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n\n        group_counter: PublicMutable<Field, Context>,\n    }\n\n    // Initializing the contract with an admin and a tree contract address\n    #[initializer]\n    #[external(\"public\")]\n    fn initialize(admin: AztecAddress, group_id: Field, tree_address: AztecAddress) {\n        let admin_storage = storage.admins;\n        admin_storage.at(group_id).write(admin);\n\n        let tree_storage = storage.merkle_trees;\n        tree_storage.at(group_id).write(tree_address);\n\n    }\n\n    #[external(\"public\")]\n    fn update_admin(new_admin: AztecAddress, group_id: Field) {\n\n        // Only admin can update admin\n        assert_eq(storage.admins.at(group_id).read(), context.msg_sender().unwrap());\n\n        let admin_storage = storage.admins;\n        admin_storage.at(group_id).write(new_admin);\n    }\n\n\n    #[external(\"public\")]\n    fn create_group(tree_address: AztecAddress, admin_address: AztecAddress) {\n        \n        let group_id_storage = storage.group_counter;\n        let group_id = group_id_storage.read() + Field::from(1);\n        group_id_storage.write(group_id);\n        let admin_storage = storage.admins;\n        admin_storage.at(group_id).write(admin_address);\n\n        let tree_storage = storage.merkle_trees;\n        tree_storage.at(group_id).write(tree_address);\n\n        let group_merkle_tree_duration_storage = storage.group_merkle_tree_duration;\n        group_merkle_tree_duration_storage.at(group_id).write(Field::from(3600)); // 1hr\n\n    }\n\n    #[external(\"public\")]\n    fn add_member(\n        group_id: Field,\n        member: Field,\n        tree_address: AztecAddress,\n    ) {\n        // Only admin can add members\n        assert_eq(storage.admins.at(group_id).read(), context.msg_sender().unwrap());\n\n        // Call LeanIMT contract to insert the member\n        LeanIMT::at(tree_address)\n            .insert(member).call(&mut context);\n\n    }\n\n}\n","path":"/Users/manishspc/HashCloak/hackathon/ethglobalBA/aztec-semaphore/group/src/main.nr"},"59":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"60":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"68":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"70":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"73":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"96":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"97":{"source":"use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"102":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"105":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"107":{"source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"108":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"110":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"111":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"112":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"113":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"114":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"115":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"116":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"117":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"134":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"146":{"source":"use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"149":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"154":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"156":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"158":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"163":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"164":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"166":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"171":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"173":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"177":{"source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"187":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"207":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"210":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"211":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"213":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"214":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"217":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"228":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"250":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"291":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"306":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"316":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"329":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"330":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"331":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"332":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"339":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"344":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"360":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"363":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"381":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"385":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}