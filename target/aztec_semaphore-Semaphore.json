{"noir_version":"1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec","name":"Semaphore","functions":[{"name":"_verify_and_vote","hash":"4792730174935782667","is_unconstrained":true,"custom_attributes":["external","internal","public"],"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"group_id","type":{"kind":"field"},"visibility":"private"},{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"11938467960935653414":{"error_kind":"string","string":"Function _verify_and_vote can only be called internally"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"add_member","hash":"874823203722618565","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"group_id","type":{"kind":"field"},"visibility":"private"},{"name":"member","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"init","hash":"17065699566277794048","is_unconstrained":true,"custom_attributes":["initializer","external","public"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"initialize_group","hash":"5842658357223309564","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"id","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnRbhs5DEX/xc95kESJlPIrRVG4qVsYMJzATRZYFPn3JWd4ZTsLCanT9qH3OPZcixSpoe1fm2+7ry8/vuyP3x9/bu4//dp8Pe0Ph/2PL4fHh+3z/vGof/21CfZf5M19vttE2dyLSt3cx6DaVOPdJgXX6JpUWZVcs2pTLZv7ZM+zq/jfq6v6JbrbUHCNrsmVXNUv6XKouLKruKofqT+1VXNwja7JlVyza3FlV3F1v+x+xfySanRNruSaXYsru4prdW2rsvux+7H7sfux+Wm+ubiyq7hW17aqBNfomlzJ1f3E/cT9qr1e81eTK7lm1+LKruJaXduqLbi6XzO/okqu2bW42nVWV8FeWA0IkAEFwAAB6NtnK8fQHGIAREACECADCsCKPBoIoAKag5X6ChFgzsmAABlQAGZIBhXQHKzWs7WWFfsKCUAAz3ckAVSApzzmAIiABPC0x5wBBcAOS0nbFhRkviDzBZkvyHxB5pdCXgCZZ2SekXlG5hmZZ2SekXkr6BWQeUbmGZkXZF6QeSvrFZB5QeYFmbfSXsEM2cAMl0MsACIgAezyZqBXFVuYlfYCVtsrREACEECXUexNrcBXYIAAKqCtkEIARICtpxoQIAMKwJzJQADmbKeutcMC1g4rRIA683JiqzPbe1k7rFDwlKxJSEsXLNAcli5YQA3Z3tRq3mJPVvMrMEB9OBtUQHOw4udi4MlMlAAEgDPBmeBs7bBCBfg2pRwAcM4wXGpeDARQAX4QJWsHtkShHRLaIaEdkrUDLy8WQAVYgPaa5WRfIAISAM4MZ4YzM0AAFdAcBM4Cw+U0t3cXBCgIUBCgFf8SV8VVFcuoWIYV/xJFRYAVAVo7LHFVLKNhGQ0BNjg3ODc4NwTYEGBDgA0BNnemsBi+vt5tMI58eT7tdjaNXMwnOrU8bU+74/Pm/vhyONxt/tkeXpYX/XzaHhd93p70Wd353fGbqhp+3x92Rq9356vD+FK9LYXqlyu32i30rnRlEicmyU6W1UP39cIiXVmkiUUNEuFRQz2HwvXKg8YepPXb3ENZyshjFgrZkLUug3IehlL+QCj8l0PR+u+hhPGu1LGFVIGFtNRGi2iTQIjtuF8DIW4fDiSPA5mVeU2pb0k+70i5bpSYZpH0RiH9d15FlWuPWYWGRt0ktDLMaMwzk3ROqbZsHJpMipQKh25SmIb7Mk1q7r1SOQ2TKhOLlmI/OpreYIex1FmzcOLeLJzHCZmvJIfzSloamaRJRigXt8h6EJ4TclNGJY4ymiZlKtw7Vs4ryLd1itBoCRMHHdvgoIPbOIhJdTIJqoJzuuh4ue61NDlCY+G+ivNm2pl+5TApCcmCZpVyUZoU+dpjVpu9VXM8b4eOi9cOkxNUJ1PcTXQ2bUMPmmxJSbiZFAq3ObS+IbHcFocOVoiDLnbkf6ug2Z6m3qPl4k7wex7cukdtt3no4d3vSKmOPXhWXagMyXyTQ+unTSu3rUHvoL3ZA4/3lSb7mjOjPnO+nB/bb6TzfOxRuXFbqVeoYr3J40+EEqlXaMz1tk6R2I8umfRrLn/XQ7+66LGw1Ns8pE+Q+u3EuOtz/WinzBze1ykzh/d2SokfLq9pOtv54NFxaVxes5tr6ZMfl4sR9O3NtUxmUBbCOrS64sVI/iYdsxKtsd8QKvFwoH7vqFGHo0aZ3OSpVhQ5tTBeRZkOoETUB1Aqwym2zD4p6Zd/fSX63d5wiuXZAFokxj7W69Ry40r6h2DlPPyUMm25gOO4pRubtu9tk/LRtp84TG+x74pi6vCuKN55m3/r8Fkfbh/2p6tftV7N6rTffj3s/OH3l+PDxbPP/z7hGfwq9nR6fNh9ezntzOn805j+94n0A62W92f7DcIehnyn0489jPZQv4XXz/WfX20x/wE=","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"8540017293698927939","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"TL3LsjS7jpz5LnvcgyRIAmC9Sg9krdbFyqxMZabLqF5eK+AE3Sfan6vOT0cwAp6Rkchc//HPf/mv//n//Pf/9K//47/9+//651/+3//45z//z3/9t3/71//+n/7t3////+9//+u//4+//9//+Of3/T/59//O/+efHP/8i//9x/75l/X3n4n/LPxn//Mv+fcfx38C/0n859R/zg//GfiP4T8T/1n4D1Y5WOVglYNVDlYZv9/977j/tfvfef+77n/3/a/f/8b9b97/3vXGXW/c9cZdb9z1xl1v3PXGXW/c9cZdb9z17K5ndz2769ldz+56dtezu57d9eyuZ3e9edebd71515t3vXnXm3e9edebd71515t3vXXXW3e9dddbd71111t3vXXXW3e9dddbd71919t3vX3X23e9fdfbd71919t3vX3X23c9v+v5Xc//1hu/D2bDatgNf2uO+UE0ZMO5EH/rDv/gb2H7/lVYw2xYDbvBG/5WtvVBNpwLX3sAvpX3B9YwG76av8P5GgXgDX8rz/FBNpwLX8sARoM1zIbVsBu8oVc+vfK5K9vXRXN+MBqsYTasht3gDdGQDefC6JVHrzx65dErj1559MqjVx698uiVR69svbL1ytYrW69svbL1yl9/zf1BNGTDufD1GGA0WMNsWA27oVeevfLslWevvHrl1SuvXnn1yqtXXr3y6pVXr7x65dUr715598q7V9698u6Vd6+8e+XdK+9eeffK3it7r+y9svfK3it7r+y9svfK3it7rxy9cvTK0StHrxy9cvTK0StHrxy9cvTK2Stnr5y9cvbK2Stnr5y9cvbK2Stnr3x65dMrVw/mB7NhNewGb4iGbDiAWT1YMBqsYTashr+V1/jAG6Lhb+XlH5wLXw8CRoM1zIbVsBu8IRp65dErW69sN5GmWcNsWA27wRuiIRtuIs35a+iVZ688e+WvB9f5YDd4QzRkw7nw9SBgNFjDbOiVV6+8euXVK389uH8fnAtfDwJGgzXMhtWwG7whGnrl3St7r/z14I4PrGE2rIbd4A3RkA3nwteDgF45euXolaNXjl45euXolaNXjl45e+XslbNXzl45e+XslbNXzl45e+XslU+vfHrl0yufXvn0yqdXPr3y6ZVPr3zuyuv3axgN1jAbVsNu8IZoyIZeefTKo1cevfLolUevPHrl0SuPXnn0yqNXtl7ZemXrla1Xtl7ZemXrla1Xtl7ZeuXZK89eefbKs1eevfLslWevPHvl2SvPXnn1yqtXXr3y6pVXr7x65dUrr1559cqrV9698u6Vd6+8e+XdK+9eeffKu1fevfLulb1X7h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHV/fg6h5c3YOre3B1D67uwdU9uLoHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e3B3D+7uwd09uLsHd/fg7h7c3YO7e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXswugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7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26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26Ybs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkvCyx38sS+70ssd/LEvu9LLHfyxL7vSyx38sS+70ssd/LEvv96DboNug26DboNug26DboNug26DboZnQzuhndjG5Gt8qSUT+tUllyMYhJPA8rSy4OohEncRHpNuk26VZZMqzwPKwsuTiIRpzERdxEJwaRbotum26bbptum26bbptum26bbptum25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26VZaMVZjE01gDiGNE4SAacRIXcROdGMQknoeDboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o9uk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLemWdEu6Jd2Sboduh26Hboduh26Hboduh26Hbue5GbPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSW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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"7721289190192760912","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"11938467960935653414":{"error_kind":"string","string":"Function _verify_and_vote can only be called internally"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"6956988932796644674","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"update_admin","hash":"13570940509383249666","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/71VvUoDQRDeu9xdTg3+oWAZC1FBIZpSLCQGxCKKFtqIHN4qB/njkkjszCOIteBDiGhh6StY2KWztElv1szqMNmYPSN+EGZ3b+abb2d2NwbrIAG2Vva9Kj/2/EJQFHMD1i2wco4h15JMC0YEXxKl6aPaTArWXLAmionpCzJckita/GXWpYSR4tlnvIgZRL+M+UU8c8BuoniqRSABc9w3GRNn3z0S41EYuyTmn2vDJhX5TaRNIIP8k2BTfi5srtwuPuxm7xuNw6OF9NvWxWP5KtNsXb+3vw+zzj7nwX+k/RuHsXde2CmflHy+4fshr1RwvehefkIUzlgEzhnKmavl88FpwMNsPahUu7hVD4Ucm2TN7KELr2Oo+iuQZFowLKJxGqzozXKPHBH4bVGvKZh81Wu/Wgq9M77HPV+3D7pnQOQb68rHiz4PddrSC8LHhrFN4gXkFTDhm6OIE4jBWhx9dxS5HMIXV+h2e+wjyfRgEG5LoRnzW8R/lujAfwNRnpgJFMcIF9Vgs+5j4hB90neO6LP/UJ/kEsdNXhl6vA/CoMopWb/7rnoXMMS7KYuDG6a/oXpW5pBFtNEYwyJW+iyBHUL5pbU0dLw+t17utlcLtLACct/DA/A73tr6yM1Tuh//BwzbFKPpCQAA","debug_symbols":"tZbdjuIwDIXfJddcJE7sJH0VhFCBMqpUFdSBlVao777ukKbtSPHF7C4XnP7QDx/nuMpLXZrT8+PY9tfbp6r2L3Ua2q5rP47d7Vw/2lvPV19KT18GVeV2ypCqPItXldGsgdWwxreCTmpYiRWSWtbI6lQF031MSum6T8o8sKzxrVYnNUkhKfOAy7EuKSalpMyDOI47NTs5PoammYysrLHhez00/UNV/bPrdupX3T2/fvR5r/svfdQD32WnTX9hZeC17ZrpaNwtT+vyo0aDDulxPo4hI4zGDcQIEHB+ZgD5FQI2CBAQQXszM4IOixUKG4YtMywgxsTgY48lhmTFTuvzLsM6V7SC/8AK/WcrEGy2osurEsoIH/yM8JEDWygiCkYsIcxGLMW/NuLKRqSYI+YlQVqM4HZQDEhO8qBY/ixVBL9lSAnV0WaIjljsqHESBJaW8siaIkQIqUXSGYJki+siNjWnw+CqjO9N9QIigsmvjghQjkeQhoWA8rCQKzdErsTppZIIJQgIHbEOE8Lxi3BpyE86SlqXOgpCTD3lifVLBe5Hk8IRKZUgEQjzktKqhu8mpHSGMK+FjZqKswbiK5SnNKfCYjFaIKTCGm9yJcZTMVog5RO9MXnWPG6jdeCz+twOm03NONGGtj51TTq9Pvvz6u7j932+M2+K7sPt3FyeQzORVjsj/t7buHPuwBsh3qjsOaTOH8bpr/8A","expression_width":{"Bounded":{"width":4}}},{"name":"vote","hash":"268395260592335949","is_unconstrained":false,"custom_attributes":["external","internal","private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"anchor_block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}}]}}]}},{"name":"sponge_blob_hash","type":{"kind":"field"}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_key","type":{"kind":"field"},"visibility":"private"},{"name":"index_bits","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":1}},"visibility":"private"},{"name":"hash_path","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_proof_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"hashed_scope","type":{"kind":"field"},"visibility":"private"},{"name":"candidate","type":{"kind":"field"},"visibility":"private"},{"name":"group_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"include_by_timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"note_hash_read_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_read_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"key_validation_requests_and_generators","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hashes","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifiers","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_call_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_call_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_logs","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_class_logs_hashes","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"anchor_block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"field"}}]}}]}}]}},{"name":"sponge_blob_hash","type":{"kind":"field"}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"314566189156328291":{"error_kind":"string","string":"Function vote can only be called internally"},"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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Oh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67zbEHybOn96vxRNP15eDYOf3X+aDTNptW0m6zJm05TNLWHt4e3h7eHt4e3h7eHt4e3h7eHt8dpj9Mepz1Oe5z2OO1x2uO0x2mP0x7RHtEe0R7RHtEe0R7RHtEe0R7RHrc9bnvc9rjtcdvjtsdtj9setz1ueWTj0qPRNJtW026yJm86TdHUHqM9RnuM9hjtMdpjtMdoj9Eeoz1Ge8z2mO0x22O2x2yP2R6zPWZ7zPaY7bHaY7XHao/VHqs9Vnus9ljtsdpjtcduj90euz12e+z22O2x22O3x26PrvPddb67znfX+e46z3YntyRr8qbTFE23KOscNJpm02pqD28Pbw9vD28Pb4/THqc9Tnuc9jjtcdrjtMdpj9Mepz2iPaI9oj2iPaI9oj2iPaI9oj2iPW573Pa47XHb47bHbY/bHrc9bnvc8sjmqEejaTatpt1kTd50mqKpPUZ7jPYY7THaY7THaI/RHqM9RnuM9pjtMdtjtsdsj9kesz1me8z2mO0x22O1x2qP1R6rPVZ7rPZY7bHaY7XHao/dHrs9dnvs9tjtsdtjt8duj90euz2sPaw9rD2sPbrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t6zzbrTySVtNusiZvOk3RdIuyzkGjqT1ue9z2uO1x2+O2x22PWx7ZgPVoNM2m1bSbrMmb/jzOToqmW/TV+aPRNJtW026yJm9qj6/OjyXdoq/OH42m2bSadpM1edNpao/ZHqs9Vnt8dX5O0mraTdbkTacpmm7RV+ePRlN77PbY7bHbY7fHbo/dHrs9rD2sPaw9rD2sPaw9rD2sPaw9rD28Pbw9vD28Pbw9vD28Pb46P3mGfXX+6BZ9dX5u0miaTX8eMZJ2kzX9eUSeTV+dP4qmP4/7++ir80ej6c/j5ihfnT/aTX8edyV502mKplv01fmj0TSbVtNuao/bHrc9vjq/eRxfnSdlk9ejz+MkzabVtJusyZtOUzTdoq/OH7XHaI/RHl+d30iyJm86TdF0i746fzSaZtNqao/ZHrM9ZnvM9pjtsdpjtcdqj9Ueqz1We6z2WO2x2mO1x26P3R67PXZ77PbY7bHbY7fHbo/dHtYe1h7WHtYe1h7WHtYe1h7WHtYe3h7eHt4e3h7eHt4e3h7eHt4e3h6nPU57nPY47XHa47THaY/THqc9TntEe0R7RHtEe0R7RHtEe0R7RHtEe9z2uO1x2+O2x22P2x63PW573Pa45ZGNZI9G02xaTbvJmrzpNEVTe4z2GO2Rv+P+G4mLuIlGdOIhBvE2fvVeOIh0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u22WzbBFQ7iJC7iJhrRiYcYRLoNug26MUsus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksusuS7Gr/IEuAgTuIibqIRnXiIQaTbpdulG7LEEhdxE43oxEMM4n04f8gS4CBO4iJuohGdeIhBpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9ENWXISJ3ERP7fxSzSiEw8xiLcxs+ThIE7iItLN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Dbpdul26Xbpdul26Xbpdul26XbbTe8o+vhIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzujFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWsmR9iCwBDuIkLuImGtGJhxhEui26LbohS3biIm6iEZ14iEG8jcgS4CDSbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt0u3S7dLt0u3S7dLt0u3S7dLt9tu+/cjDuIkLuImGtGJ6eaJQbyNyJKbOIiTuIibaEQnHmIQb+Ok26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut93s9yMO4iQu4iYa0YmHGES6MUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJYdZcpglh1mSrah/zz4SN9GITjzEIN7GzJKHgziJdBt0G3TLLPn+3MbMxtTCIN7GzJKHgziJi7iJRqTbpNuk26Tbotui26LbotuiW2bJtEQnHmIQb2NmycNBnMRF3ES6bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3odul26Xbpdul26Xbpdul26Xbpdtste10LB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZgr7XeRI30YhOPMQg3kZkCXAQJ5Fuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26IYsuYlGdOLnln/eC32vD29jZsnDQZzERdxEIzqRbkG3oNul26Xbpdul26Xbpdul26Xbpdstt4W+14eDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkG3oFvQLegWdAu6Xbpdul26Xbpdul26Xbpdul26MUsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QyS9D3+v1J3YW+14dBTDf/EFkCHMRJXMRNNKITDzGIdHO6IUt+iZO4iJtoRCceYhBvI7IESLdDt0O3Q7dDt0O3Q7dDt0O3oFvQLegWdAu6Bd2CbkG3oFvQ7dLt0u3S7dLt0u3S7dLt0u3S7bYb+l4fDuIkLuImGtGJhxhEug26DboNug26ZZZsSzSiEz+37YlBvI3IkpM4iJO4iJtoRCceYhBv46Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut93Q9/pwECdxETfRiE48xCDSbdAN91534iQu4iYa0YmHGMTbiHuvQLpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26HboVvQLegWdAu6Bd2CbkG3oFvQLeh26Xbpdul26Xbpdul26Xbpdul22w19rw8H8XOzkbiIm/i5Gf6tEw/xczNPvI2ZJQ8HcRIXcRON6MRDpNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oduh26Hboduh26Hboduh26HbodugXdgm5Bt6Bb0C3oFnQLugXdgm6Xbpdul26Xbpdul26Xbpdul2633dD3+nAQJ3ERN9GITjzEINKNWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4sySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMEvS9+i9xECdxETfRiE48xCDexkm3SbdJt0m3SbdJt8yS71XSC32vD4OYx/bdvkHf68NBnMRF3EQjOvEQg0i3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdLt0u3S7dLt0u3S7dLt0u3S7dbruh7/XhIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26QbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS9D3eoCDOImf2/HETTTi5/a9Ln2h7/VhED+3mB9mljwcxElcxE00ohMPMYh0O3Q7dDt0yyyJSNxEI35uN9chs+RhED+3m+uQWfJwEP/c/h6pJi7iJhrRiYcYxNv4ZUnhINLt0u3S7dLt0u3S7dLttlv2vRYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oxiy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssuZ0l+9dZsn+dJfvXWbJ/nSX711myf50l+9dZsn+dJfvXWbJ/P7oNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Semaphore::_verify_and_vote_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::_verify_and_vote_parameters","fields":[{"name":"root","type":{"kind":"field"}},{"name":"nullifier","type":{"kind":"field"}},{"name":"group_id","type":{"kind":"field"}},{"name":"candidate","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Semaphore::add_member_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::add_member_parameters","fields":[{"name":"group_id","type":{"kind":"field"}},{"name":"member","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Semaphore::init_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::init_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Semaphore::initialize_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::initialize_group_parameters","fields":[{"name":"id","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Semaphore::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"Semaphore::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::sync_private_state_parameters","fields":[]}}]},{"kind":"struct","path":"Semaphore::update_admin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::update_admin_parameters","fields":[{"name":"new_admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Semaphore::vote_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Semaphore::vote_parameters","fields":[{"name":"secret_key","type":{"kind":"field"}},{"name":"index_bits","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"hash_path","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"merkle_proof_length","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"hashed_scope","type":{"kind":"field"}},{"name":"candidate","type":{"kind":"field"}},{"name":"group_id","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Semaphore"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"next_group_id","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"groups","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"nullifiers","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"tally","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Semaphore {\n    use dep::aztec::protocol_types::traits::{Deserialize, Packable, Serialize, FromField};\n    use aztec::macros::functions::{external, internal, initializer};\n    use aztec::{macros::storage::{self, storage}, state_vars::{Map, PublicMutable}};\n    use binary_merkle_root::binary_merkle_root;\n    use ec::bjj::BabyJubJubParams;\n    use ec::Curve;\n    use ec::CurveTrait;\n    use ec::ScalarField;\n    use merkle_trees::merkle::MerkleTree;\n    use merkle_trees::types::{Modifier, MT_Creator};\n    use poseidon::poseidon2::Poseidon2;\n    use std::field::bn254::assert_lt;\n    use aztec::protocol_types::address::AztecAddress;\n\n    #[derive(Deserialize, Packable, Serialize, Eq)]\n    struct Group {\n        merkleTree: Field,\n        next_member_index: u64,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        next_group_id: PublicMutable<Field, Context>,\n        groups: Map<Field, PublicMutable<Group, Context>, Context>,\n        nullifiers: Map<Field, PublicMutable<bool, Context>, Context>,\n        tally: Map<Field, Map<Field, PublicMutable<Field, Context>, Context>, Context>, // (groupID -> (candidate -> vote_count))\n        admin: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[initializer]\n    #[external(\"public\")]\n    fn init(admin: AztecAddress) {\n        let admin_storage = storage.admin;\n        admin_storage.write(admin);\n    }\n\n    #[external(\"public\")]\n    fn update_admin(new_admin: AztecAddress) {\n        // Only admin can update admin\n        assert_eq(storage.admin.read(), context.msg_sender().unwrap());\n\n        let admin_storage = storage.admin;\n        admin_storage.write(new_admin);\n    }\n\n\n    #[external(\"public\")]\n    fn initialize_group(id: Field) {\n        // Only admin can initialize groups\n        assert_eq(storage.admin.read(), context.msg_sender().unwrap());\n\n        // let mt = MerkleTree::<Field>::new(poseidon2_hash_2);\n        let groups = storage.groups;\n        let g = Group { merkleTree: Field::from(0), next_member_index: 0 };\n        groups.at(id).write(g);\n    }\n\n    #[external(\"public\")]\n    fn add_member(\n        group_id: Field,\n        member: Field,\n    ) {\n        // Only admin can add members\n        assert_eq(storage.admin.read(), context.msg_sender().unwrap());\n\n        let groups = storage.groups;\n        let mut group = groups.at(group_id).read();\n        let mut mt = MerkleTree::<Field>::from(group.merkleTree, poseidon2_hash_2);\n        mt.add(member, Field::from(group.next_member_index), [Field::from(0); 10]);\n        group.merkleTree = mt.root;\n        group.next_member_index += 1;\n        groups.at(group_id).write(group);\n    }\n\n    global MAX_DEPTH: u32 = 10;\n    // This is a 251 bit value.\n    global L: Field = 2736030358979909402780800718157159386076813972158567259200215660948447373041;\n\n    // Generator point of Baby Jubjub curve.\n    // ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13\n    global BASE8: [Field; 2] = [\n        5299619240641551281634865583518297030282874472190772894086521144482721001553,\n        16950150798460657717958625567821834550301663161624707787222815936182638968203,\n    ];\n\n    #[contract_library_method]\n    fn poseidon2_hash_2(input: [Field; 2]) -> Field {\n        Poseidon2::hash(input, 2)\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _verify_and_vote(root: Field, nullifier: Field, group_id: Field, candidate: Field) {\n        // check root\n        let current_root = storage.groups.at(group_id).read().merkleTree;\n        assert_eq(root, current_root);\n        //assert nullifier does not exists\n        assert_eq(storage.nullifiers.at(nullifier).read(), false);\n        //store nullifier\n        storage.nullifiers.at(nullifier).write(true);\n        // cast the vote\n        let new_tally = storage.tally.at(group_id).at(candidate).read() + 1;\n        storage.tally.at(group_id).at(candidate).write(new_tally);\n    }\n\n    #[external(\"private\")]\n    #[internal]\n    fn vote(\n        secret_key: Field,\n        index_bits: [u1; MAX_DEPTH], // these bits indicate the order of inputs for hashing of the merkle proof\n        hash_path: [Field; MAX_DEPTH], // the Merkle Tree inclusion proof\n        merkle_proof_length: u32, // the number of non-zero elements in hash_path\n        hashed_scope: Field,\n        candidate: Field,\n        group_id: Field,\n    ) {\n        // Part 1\n        // Ensure secret_key < l.\n        assert_lt(secret_key, L);\n\n        // Identity generation.\n        // The public key is derived by multiplying the generator point with the secret key,\n        // interpreted as a scalar.\n        let generator: Curve<BabyJubJubParams> = Curve { x: BASE8[0], y: BASE8[1] };\n        // ScalarField is parameterised by the number of 4-bit slices it contains.\n        // Since secret key is already known to be max 251 bits, there are 63 slices.\n        let secret_scalar: ScalarField<63> = ScalarField::from(secret_key);\n        let pubkey = generator.mul(secret_scalar);\n\n        // Obtain the identity commitment by hashing the public key\n        let identity_commitment = poseidon2_hash_2([pubkey.x, pubkey.y]);\n\n        // Part 2\n        // Calculates merkle root by repeatedly hashing with the elements from the merkle proof.\n        // Depending on the index bit, we swap the siblings for hashing or not.\n        let root = binary_merkle_root(\n            poseidon2_hash_2,\n            identity_commitment,\n            merkle_proof_length,\n            index_bits,\n            hash_path,\n        );\n\n        // Part 3\n        // Obtain the nullifier by hashing the hashed scope and secret key.\n        let nullifier = poseidon2_hash_2([hashed_scope, secret_key]);\n\n        // TODO: compare the nullifier and root to the public storage & update the nullifier map\n        Semaphore::at(context.this_address())\n            ._verify_and_vote(root, nullifier, group_id, candidate)\n            .enqueue(&mut context);\n    }\n\n}\n","path":"/Users/manishspc/HashCloak/hackathon/ethglobalBA/aztec-semaphore/src/main.nr"},"59":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"60":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"67":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"68":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"70":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"73":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"96":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"97":{"source":"use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"102":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"105":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"107":{"source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"108":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"110":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"111":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"112":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"113":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"114":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"115":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"116":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"117":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"134":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"146":{"source":"use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"149":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"154":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"155":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"156":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"157":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"158":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"163":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"164":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"166":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"171":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"173":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"177":{"source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"187":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"207":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"210":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"211":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"213":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"214":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"217":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"228":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"250":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"291":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"306":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"316":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"329":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"330":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"331":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"332":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"339":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"344":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"360":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"362":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"363":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"381":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"385":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"395":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/Users/manishspc/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"403":{"source":"mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n","path":"/Users/manishspc/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"},"404":{"source":"use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n","path":"/Users/manishspc/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"},"407":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, MT_Creator};\n\npub struct MerkleTree<T> {\n    pub root: T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> MT_Creator<T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, hasher }\n    }\n\n    fn from(root: T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, hasher)\n    }\n\n    fn new(hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let root = self.calculate_root(leaf, indexes, hash_path);\n        assert(self.root == root);\n    }\n}\n\nimpl<T> Modifier<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let (old, new) = self.calculate_two_roots(leaf, indexes, hash_path);\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn delete<let N: u32>(&mut self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let (new, old) = self.calculate_two_roots(leaf, indexes, hash_path);\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(&mut self, leaf: T, old_leaf: T, indexes: Field, hash_path: [T; N]) {\n        let index_bits: [u1; N] = indexes.to_le_bits();\n\n        let mut old_parent = old_leaf;\n        let mut new_parent = leaf;\n\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if index_bits[i] == 0 {\n                new_parent = (self.hasher)([new_parent, sibling]);\n                old_parent = (self.hasher)([old_parent, sibling]);\n            } else {\n                new_parent = (self.hasher)([sibling, new_parent]);\n                old_parent = (self.hasher)([sibling, old_parent]);\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn calculate_root<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_le_bits();\n        let mut node = leaf;\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if index_bits[i] == 0 {\n                let left = node;\n                let right = sibling;\n                node = (self.hasher)([left, right]);\n            } else {\n                let left = sibling;\n                let right = node;\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = leaf;\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            if i == 0 {\n                root_without_leaf = hash_path[i];\n            }\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if index_bits[i] == 0 {\n                root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n                if (root_without_leaf != sibling) {\n                    root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                }\n            } else {\n                root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                if (root_without_leaf != sibling) {\n                    root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                }\n            }\n        }\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/Users/manishspc/nargo/github.com/zk-kit/zk-kit.noir/merkle-trees-v0.0.1/packages/merkle-trees/src/merkle.nr"}}}